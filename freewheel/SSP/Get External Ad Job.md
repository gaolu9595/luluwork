# Get External Ad Job (DE-SE-SFX)
1. 总述：
	[Log In - FreeWheel WiKi](https://wiki.freewheel.tv/display/~lugao/Get+External+Ad+Job)
	首先external ad是指那种除了internal的bidder，	比如ad-served、direct-buy和sold-by-publisher这几种bidder带来的ad之外的其他ad。这些ad不是在我们系统里提前book好的，是从每次真实的bid response里带过来的，所以DE在一开始是没有这些ad的各种内容属性的，比如duration、长宽啊这些，就没办法针对这些ad做filter的这些决策，很难保证这个ad的质量，所以需要一个叫做get external ad的job来专门解析ad的内容属性，让DE可以更好的提供服务。get external ad job是一个联动DE、SE和UI三方的一个复杂的任务，本质上其实就是对传回的每个external ad做识别做内容属性的解析，并且book到我们系统里。

2. DB Schema：
	这里列出了整个get external ad过程中涉及到的一些mysql表和它们的关键字段，以及它们互相之间的对照和关联，比如说一个brand会唯一地与一个advertiser对应，但是一个advertiser可以拥有多个brand；类似的还有campaign和brand之间的关系、brand_domain和brand之间的联系。细节会在后面的处理逻辑里面再介绍。

3. DE：
DE这里做的事其实很少，主要就是为从open-rtb、passback和marketplace传回来的每个external_ad都生成一个external_ad_id，然后去mysql里边找有没有与它相关的adInfo；如果有的话，就会用这个对应的internal_ad进行后面一系列正常的bid-response分析流程；如果没有的话，这个bid-response就会被直接filter掉，因为这样的ad如果被投放出来质量得不到保证，风险比较大，同时DE会在external_ad这个表里增加一条相关的记录，status=0表示unprocessed，交给SE和UI后面做信息补全
这里面有一些细节：
	1. 生成external_ad_id的方法，因为buyer的不同会有一些差异。
		1. 如果是open-rtb的……
		2. 如果是passback的……
		3. 如果是marketplace的……
	2. 这三种方式共同的一点就是都需要以bidderId开头。bidderId其实在bid-response里是没有相应字段的，DE要通过seat来得到bidderId。因为特定dsp的每个seat在不同的agency里面都对应不同但唯一的bidderId，所以可以根据buyer-platform、seat和agency这几个关键字段查bidder表，来获得bidderId。还有一点，如果我们收到的seat目前还没有和任何bidder关联起来，那么就会用generic bidderId（这个是我们发bid-request的时候使用的）
	3. 还有一点就是，如果没找到external_ad对应的internal_ad，或者找到的internal_ad还没有来得及做信息补全（creative是空的），DE都会记成filter类型是XXX的#bf
	4. 然后，brand/duration等这些属性属于和ad内容很相关的一个属性，在filter的时候是比较重要的，SE和UI做信息补全也就是为了让DE在filter的时候能有更充分的信息做决策
为什么不在DE过程中直接补全信息？==因为DE对实时性要求很高，虽然external_ad的解析是毫秒级的，但是当external_ad非常多时，要解析他们的信息然后写数据库，会很耗时

4. SE：
SE这边主要就是，在发现一个没有和任何internal_ad关联的新external_ad的时候，需要给它创建好相应的campaign和internal_ad，建立起external_ad和internal_ad的mapping。
为什么由SE来插入banner和campaign呢？==因为SE的很多topic都需要用到adId，campaignId这些数据，所以这些信息必须在我们这儿创建出来，才能统计。
	1. 如果Scribe Log里面的external_ad_id是null，那这就是一个internal bidder相关的log；如果不是null的话，那这就是一个external bidder相关的log，SE在get-external-ad这个任务下只关注那些external bidder相关的log。
	2. 如果log里或者mysql里有和这个external_ad相对应的internal_ad，说明这不是新的external_ad。如果log里没有ad，但mysql里面有mapping关系，那SE就得把这个adId读出来填到LogEvent对象里，然后做stats分析；如果log里有ad，mysql里没有mapping关系，SE就得把log里的这种mapping关系新增到external_ad_mapping表里面去。
	3. 但是，如果log以及mysql中都找不到这个external_ad对应的internal_ad，就说明这是个新的external_ad，SE就需要为这个external_ad创建新的internal_ad和campaign，然后再建立起external_ad和新创建的internal_ad之间的mapping关系
	这里面有一些细节：
		1. 有时候SE需要对external_ad_id做一些更新，这种情况不多，但是也存在。前面讲过，如果DE在创建external_ad_id的时候，收到的这个seat还没有和任何bidder关联起来，那传过来的external_ad_id中的bidderId是generic的，然后到SE处理的时候，查seat和bidder表发现这个seat已经有关联的bidder了，那我们就得更新一下这个bidderId，然后往external_ad表里面再插入一条新的status=0的external_ad_id记录
		2. 创建campaign的时候，有一些信息是有的，重要的比如说campaignname、original_campaignid和externalref等。从这里可以看出一点，就是每个external_ad在我们的系统里面都唯一对应着一个campaign，这跟ad-served那种模式是不一样的，那种模式下一个campaign中可以包含多个internal的ad。此外，只有在EPB external_ad的campaign里，original_campaignid才是有值的。
		3. 创建banner的时候，campaignid、externalref这些信息也是现在就有的

5. SFX:
UI这边就是大头的信息补全逻辑了，UI会有一个专门的cron job来定时地对external_ad这个表里面那些还没有解析过的external_ad做参数解析，获取这个ad具体的那些内容属性，比如说广告视频的时长、长宽、比特率等；然后也会通过查mysql或者是手动的方式来为每个ad做brand的管理。从UI的执行log可以看出来整个过程可以分为9个步骤，下面就详细讲一下
	1. external_ad中的ad，有好几种status值……；
	2. step1是尝试去mysql中找到这个external_ad对应的campaign以及内部ad，主要方式就是查campaigns表中的externalref字段，和banners表中的campaignId字段；
	3. 前面讲过，EPB传来的external_ad的id构成是SMI的bidderId和SMI中实际的adId的组合，相当于是SMI中的banner的一层包装，本质上这个external_ad和SMI中实际对应的ad的内容属性都是一样的。所以step2就是对EPB传来的这种external_ad做拆包装的处理，然后去查mysql中SMI中原始的ad的数据。如果原始的ad是SMI的internal_ad，或者原始的是已经处理过的external_ad，那么会把它们的campaign和banner信息都直接同步过来。（EPB的external_ad，它存储在external_ad这个表的时候，adm和nurl都设为null）
	4. 如果不是EPB的external_ad，那么就要先从bid-response中传来的adm和nurl这两个参数中来取得这个ad的VAST内容，从VAST里面再提取内容属性。如果adm不为空，那么直接用adm中的VAST内容；否则就要通过http协议去请求nurl再获取到VAST内容（这是两种Ad Serving的方式）
		1. 第一种通过adm来提取VAST的方式，它能减少win ad播放失败的概率；
		2. 第二种call nurl的这种win notice方式，可以减少网络带宽，并且可以让dsp方更加灵活地投放ad
	5. 从VAST里面就可以提取到mediaFiles（也就是creative）的信息，比如duration、height、width等等，然后就可以向creative表里面插入这些记录，并且把这些creative link到这个ad上面，更新banner表里面的相关信息
	6. UI还要判断mediaFiles的url是不是和系统里已知的vpaid组件client-side-adex的url匹配，来更新banner表中的is_client_side_index字段
	7. 接下来就是另一个很重要的一个环节就是获取ad的brand信息，大体的方法就是通过ad被点击后跳转到的clickthrough的url来解析。providedClickThrough是由bid-response中的adomain字段转换过来的，除此之外UI还会从VAST的VideoClicks/AdParameters/Extensions/mediaFileUrl里面解析clickThrough。如果VAST里面能解析clickThough就会优先用这个，没有的话就用bid-response里面提供的那个。接下来，要判断这个domain是不是在我们的blacklist里面，如果在的话就要把这个external_ad的status设置成skip（也就是3），这个external_ad以后就不会再被解析了。如果不在blacklist里面，就去查brand_domain表看看能不能找到对应的我们已知的brand，能找到就用它来更新campaigns的相关字段，如果找不到brand就新建一条brand字段为null的brand_domain表的记录，这个domain也就是orphan domain了。然后，还会更新brand_domain里面的一些last_bidder、last_ad的信息。如果是orphan domain的话，会出现在UI的这个页面上，由我们的团队来手动的补全brand信息。
	8. 上面就是整个的流程，最后还要做一个EPB COPIES UPDATE的收尾操作。前面我们针对EPB传来的external_ad的处理中，只对那种原始ad是internal_ad或者已经处理过的external_ad做了campaign和banner的同步。现在这个Step9就是，针对SMI中那些直到这次任务才处理完的external_ad，来更新所有以它们为基础做包装的EPB external_ads的campaign、banner和creative信息。EPB的external_ad的各类信息，都通过original的SMI中的external_ad信息来更新


