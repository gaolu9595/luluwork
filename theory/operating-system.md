# Operating System

[TOC]

## 多线程、并行、并发，逻辑线程 与 CPU核数物理线程数的关系

1. 计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)，由于**超线程**技术，实际上可以并行的线程数量通常是物理核数的两倍，这也是操作系统看到的核数。我们只care可以并行的线程数量，所以之后所说的核数是操作系统看到的核数，所指的核也是超线程技术之后的那个核（不是物理核）。

2. 进程是操作系统资源分配（内存，显卡，磁盘）的最小单位，线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程），一个进程可以有一个或多个线程，线程之间共享进程的资源，通过这样的范式，就可以减少进程的创建和销毁带来的代价，可以让进程少一点，保持相对稳定，不断去调度线程就好。如果计算机有多个cpu核，且计算机中的总的线程数量小于核数，那线程就可以**并行**运行在不同的核中，如果是单核多线程，那多线程之间就不是并行，而是**并发**，即为了均衡负载，cpu调度器会不断的在单核上切换不同的线程执行，但是我们说过，一个核只能运行一个线程，所以并发虽然让我们看起来不同线程之间的任务是并行执行的，但是实际上却由于增加了线程切换的开销使得代价更大了。如果是多核多线程，且线程数量大于核数，其中有些线程就会不断切换，并发执行，但实际上最大的并行数量还是当前这个进程中的核的数量，所以盲目增加线程数不仅不会让你的程序更快，反而会给你的程序增加额外的开销。

3. 任务可以分为**计算密集型和IO密集型**，假设我们现在使用一个进程来完成这个任务，对计算密集型任务，可以使用【核心数】个线程，就可以占满cpu资源，进而可以充分利用cpu，如果再多，就会造成额外的开销；对于IO密集型任务（**涉及到网络、磁盘IO的任务都是IO密集型任务。按照这个我理解的IO就是指把内容从硬盘上读到内存的过程，或者是从网络上接收信息到本机内存的过程**），线程由于被IO阻塞，如果仍然用【核心数】个线程，cpu是跑不满的，于是可以使用更多个线程来提高cpu使用率。**IO所需要的CPU资源非常少。大部分工作是分派给DMA完成的。**

4. 实现并行计算有三种方式，多线程，多进程，多进程+多线程。如果是多进程，因为每个进程资源是独立的（地址空间和数据空间），就要在操作系统层面进行通信，如管道，队列，信号等；多线程的话会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，但方便的同时会造成变量值的混乱，所以要通过线程锁来限制线程的执行

5. 其他语言，CPU 是多核时是支持多个线程同时执行。但在 Python 中，无论是单核还是多核，一个进程同时只能由一个线程在执行。其根源是 GIL 的存在。GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 Python 设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。所以**多线程在python中很鸡肋**。

6. ***多线程本质上是为了充分利用CPU资源而出现的***。

   **简单来说，线程一定是运行在核心上的。硬件上的多核多线程核C++的多线程大致相当于逻辑概念和实体概念的区别**。

   CPU有个超线程的概念，是有对应实体的，是在一个核心同时运行两个物理线程。大致是有一个运算单元配合两套逻辑处理单元，寄存器等，有时候会出现某个线程仅需要其中一部分资源时，可以使两个线程并行执行。但是这个核心上的两个线程恰巧用到了只有一套的部分（比如某个处理单元），那么就得有一个等待。所以超线程大部分应用只能提供大概5-15%的性能提升，和任务相关。所以会有像2核2线程的i3，或者4核8线程的i7这种区别。**主要还是靠核心，任务一定是运行在实际处理单元上的**。

   然后C++的多线程，这是一个逻辑概念，其实就是把一个任务拆成并行处理的多个任务，每个任务都是运行在物理实体上（可以认为是CPU核心，超线程的事情不要可以先去管他）。但是，**并不是说你一个线程就要固定占用一个核心，因为程序是有时间序列的**。这部分操作系统分时并行部分讲的很详细。大致就是由于某些原因（IO，时序，需要等待其他线程的结果或通知之类），不是所有线程在所有时间都在同时用到CPU核心资源，所以就会有操作空间。就像公交车，如果要求每人都要有座位（线程要用核心），如果有20个座位，10个站，并不意味着只能拉20个人，每一站可能会有人上上下下(操作系统CPU调度），一趟拉上百人是很平常的事情。但是，同一时刻每个座位只能有一个人，但是下一站就可能换人，这个就类似运行线程和CPU核心的关系，具体谁占用，由操作系统决定。但是这个调度时间非常短，印象中之前windows是每秒调度64次。



## CPU主要性能参数

1. 主频：严谨的说他是CPU内核的时钟频率，但是我们也可以直接理解为**运算速度**，就是CPU运算时的工作频率，在单核时代它是决定CPU性能的最重要指标。外频是由主板提供，CPU以这个频率跟系统其他的配件进行沟通，因此，外频亦称为系统总线频率或前端总线速度（FSB）
2. 核心数线程数：虽然提高频率能有效提高CPU性能，但受限于制作工艺等物理因素，早在2004年，**提高频率便遇到了瓶颈**，于是Intel/AMD只能另辟途径来提升CPU性能，双核、多核CPU便应运而生。目前主流CPU有双核、三核和四核，六核也将在今年发布。其实增加核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是1:1对应关系，也就是说四核CPU一般拥有四个线程。但Intel引入**超线程技术**后，使核心数与线程数形成1:2的关系，如四核Core i7支持八线程（或叫作八个逻辑核心），大幅提升了其多任务、多线程性能。我们更多听到的是，这个CPU是几核几核的，如2核、4核、6核、8核、16核等等。
3. 架构：CPU架构，目前没有一个权威和准确的定义，简单来说就是**CPU核心的设计方案**。目前CPU大致可以分为X86、IA64、RISC等多种架构，而个人电脑上的CPU架构，其实都是基于X86架构设计的，称为**X86**下的微架构，常常被简称为CPU架构。
4. 缓存：Cache，它也是决定CPU性能的重要指标之一。为什么要引入缓存？在解释之前必须先了解程序的执行过程，首先从硬盘执行程序，存放到内存，再给CPU运算与执行。由于内存和硬盘的速度相比CPU实在慢太多了，每执行一个程序CPU都要等待内存和硬盘，引入缓存技术便是为了解决此矛盾，缓存与CPU速度一致，**CPU从缓存读取数据比CPU在内存上读取快得多，从而提升系统性能**。当然，由于CPU芯片面积和成本等原因，缓存都很小。目前主流级CPU都有一级和二级缓存，高端的甚至有三级缓存。
5. ref：https://www.cnblogs.com/yilang/p/10989349.html



## GPU && CPU

CPU和GPU之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。

CPU需要很强的通用性来处理各种不同的数据类型，同时逻辑判断又会引入大量的分支跳转和中断的处理，这些都使得CPU的内部结构异常复杂。GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。

https://blog.csdn.net/CYJ2014go/article/details/80283007



## IO模型

IO简单理解就是“信息交换”。

计算机硬件上使用DMA来访问磁盘等IO，也就是请求发出后，CPU就不再管了，直到DMA处理器完成任务，再通过中断告诉CPU完成了。 所以，单独的一个IO时间，对CPU的占用是很少的，阻塞了就更不会占用CPU了，因为程序都不继续运行了，CPU时间交给其它线程和进程了。

**socket**的含义就是两个应用程序通过一个双向的通信连接实现数据的交换，连接的一段就是一个socket，又称为套接字。实现一个socket连接通信至少需要两个套接字，一个运行在服务端（插孔），一个运行在客户端（插头）。

**同步/异步是“消息通知机制"，阻塞/非阻塞是“等待消息通知时的行为状态”**，可产生几种不同的组合

同步：发了请求以后，要一直参与这个请求

异步：发了请求以后什么都不管了，只等请求完成通知

阻塞：请求执行条件不满足时，要一直等待

非阻塞：请求执行条件不满足时，可以先去干别的，不用干等只需要轮询

【（同步）阻塞IO，（同步）非阻塞IO，异步IO】【IO复用，信号驱动IO】

references：

https://zhuanlan.zhihu.com/p/115912936

https://cloud.tencent.com/developer/article/1005481



## 异步编程和多线程编程

**异步编程为了不阻塞而产生**

**多线程编程为了榨干CPU剩余价值而产生**

**共同点：**

```
异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性
```

**不同点：**

        （1）线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。
    
        多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线              程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现
    
      （2）异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完                全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序              主要使用回调方式进行处理，与普通人的思维方式有些 初入，而且难以调试。

**这里有一个疑问。异步操作没有创建新的线程，**我们一定会想，比如有一个文件操作，大量数据从硬盘上读取，若使用单线程的同步操作自然要等待会很长时间，但是若使用异步操作的话，我们让数据读取异步进行，二线程在数据读取期间去干其他的事情，我们会想，这怎么行呢，异步没有创建其他的线程，一个线程去干其他的事情去了，那数据的读取异步执行是去由谁完成的呢？实际上，本质是这样的。

熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直 接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开 始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。

即CPU在数据的长时间读取过程中 ，只需要做两件事，第一发布指令，开始数据交换；第二，交换结束，得到指令，CPU再进行后续操作。而中间读取数据漫长的等待过程，CPU本身就不需要参与，顺序执行就是我不参与但是我要干等着，效率低下；异步执行就是，我不需要参与那我就去干其他事情去了，你做完了再通知我就可以了（**回调**）。

**回调函数**：就是函数b被当作参数传入另外一个函数a当中，并在那个函数a中被调用，那么那个函数b就是回调。 异步与回调并没有直接的联系，回调只是异步的一种实现方式。 总结：因为异步任务不能直接拿到结果，于是我们传一个回调给异步任务，在异步完成任务时调用回调，调用的时候把结果作为参数。

但是你想一下，**如果有一些异步操作必须要CPU的参与才能完成呢**，即我开始的那个线程是走不开的，这该怎么办呢，在.NET中，有线程池去完成，线程池会高效率的开启一个新的线程去完成异步操作，在python中这是系统自己去安排的，无需人工干预，这就比自己创建很多的线程更加高效。

**总结：**

       （1）“多线程”，第一、最大的问题在于线程本身的调度和运行需要很多时间，因此不建议自己创建太大量的线程；第二、共享资源的调度比较难，涉及到死锁，上锁等相关的概念。
    
       （2）“异步” ，异步最大的问题在于“回调”，这增加了软件设计上的难度。

在实际设计时，我们可以将两者结合起来：

       （1）当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。异步特别适用于大多数IO密集型的应用程序。
       （2）而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往 往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处 理大量的并发操作时就不合适了。


**引起线程上下文切换的原因**

对于我们经常使用的抢占式操作系统而言，引起线程上下文切换的原因大概有以下几种：

1. 当前执行任务的时间片用完之后，系统CPU正常调度下一个任务
2. 当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务
3. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务
4. 用户代码挂起当前任务，让出CPU时间
5. 硬件中断



**异步编程介绍**：https://www.jianshu.com/p/c4dc7866eb81

**Reactive Streams异步编程范式**介绍：

https://mp.weixin.qq.com/s?__biz=MzI1MjkyMDcwOA==&mid=2247484027&idx=2&sn=034fc30008e064a6b372107e5bf2d757&chksm=e9dd1490deaa9d866f81fe7bcfe85433faf23b9424db9d25c36628232df398b502fd70a23337&token=1032978025&lang=zh_CN#rd

https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md

